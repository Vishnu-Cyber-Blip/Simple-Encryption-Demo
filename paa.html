﻿<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Elliptic Curve Visualizer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: black;
      font-family: sans-serif;
      color: white;
      overflow: hidden;
    }

    #sidebar {
      font-size: 20px;
      position: fixed;
      top: 0;
      left: 0;
      width: 320px;
      height: 100vh;
      background-color: #111;
      padding: 20px;
      box-sizing: border-box;
      border-right: 1px solid #333;
      overflow-y: auto;
    }

    #curveCanvas {
      position: absolute;
      left: 320px;
      top: 0;
      width: calc(100vw - 320px);
      height: 100vh;
      display: block;
      background-color: black;
    }

    h2 {
      color: #00ffff;
      margin-top: 0;
    }

    p, li {
      font-size: 19px;
      line-height: 1.5;
    }

    code {
      background: #222;
      padding: 2px 4px;
      border-radius: 4px;
      color: #0ff;
    }

    .toggle-label {
      display: flex;
      align-items: center;
      margin-top: 20px;
      gap: 10px;
      font-size: 18px;
    }

    .toggle-label input {
      transform: scale(1.3);
    }
  </style>
</head>
<body>
  <a href="index.html" style="
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: #00bfff;
    color: black;
    padding: 10px 18px;
    border-radius: 6px;
    font-family: sans-serif;
    font-size: 16px;
    text-decoration: none;
    z-index: 9999;
  ">⬅ Back</a>

  <div id="sidebar">
    <h2>Elliptic Curve Viewer</h2>
    <p>This tool visualizes point addition on an elliptic curve:</p>
    <p><code>y² = x³ + ax + b</code> where <code>a = -1</code> and <code>b = 1</code></p>

    <h3>Geometric Point Addition</h3>
    <ul>
      <li>Pick two points <code>P</code> and <code>Q</code> on the curve</li>
      <li>Draw the line through them (or tangent if <code>P = Q</code>)</li>
      <li>The line intersects the curve at a third point <code>R'</code></li>
      <li>Reflect <code>R'</code> across the x-axis to get <code>R = P + Q</code></li>
    </ul>

    <h3>How to Use</h3>
    <ul>
      <li>Drag the blue (P) and green (Q) points</li>
      <li>Watch the red intersection and purple sum</li>
      <li>Use <code>+</code> / <code>-</code> to zoom in/out</li>
    </ul>

    <label class="toggle-label">
      <input type="checkbox" id="labelToggle" checked />
      Show Labels
    </label>
  </div>

  <canvas id="curveCanvas"></canvas>

  <script>
    const canvas = document.getElementById('curveCanvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    function resizeCanvas() {
      width = window.innerWidth - 320;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener("resize", () => {
      resizeCanvas();
      render();
    });
    resizeCanvas();

    const a = -1;
    const b = 1;
    let scale = 100;
    const rangeX = 4;
    let origin = { x: width / 2, y: height / 2 };
    let showLabels = true;

    document.getElementById("labelToggle").addEventListener("change", (e) => {
      showLabels = e.target.checked;
      render();
    });

    function toCanvas(p) {
      return {
        x: origin.x + p.x * scale,
        y: origin.y - p.y * scale
      };
    }

    function fromCanvas(p) {
      return {
        x: (p.x - origin.x) / scale,
        y: (origin.y - p.y) / scale
      };
    }

    function drawGrid() {
      const spacing = scale;
      ctx.strokeStyle = "#222";
      ctx.lineWidth = 1;
      for (let x = 0; x < width; x += spacing) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }

    function drawCurve() {
      ctx.beginPath();
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 3;
      for (let x = -rangeX; x <= rangeX; x += 0.005) {
        const rhs = x ** 3 + a * x + b;
        if (rhs < 0) continue;
        const y = Math.sqrt(rhs);
        const p = toCanvas({ x, y });
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();

      ctx.beginPath();
      for (let x = -rangeX; x <= rangeX; x += 0.005) {
        const rhs = x ** 3 + a * x + b;
        if (rhs < 0) continue;
        const y = -Math.sqrt(rhs);
        const p = toCanvas({ x, y });
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    function drawPoint(p, color, label = "") {
      const cp = toCanvas(p);
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.arc(cp.x, cp.y, 6, 0, 2 * Math.PI);
      ctx.fill();

      if (label && showLabels) {
        ctx.fillStyle = "white";
        ctx.font = "16px sans-serif";
        ctx.fillText(label, cp.x + 8, cp.y - 8);
      }
    }

    function inversePoint(p) {
      return { x: p.x, y: -p.y };
    }

    function addPoints(P, Q) {
      if (P.x === Q.x && P.y === -Q.y) return null;
      let lambda;
      if (P.x === Q.x && P.y === Q.y) {
        lambda = (3 * P.x ** 2 + a) / (2 * P.y);
      } else {
        lambda = (Q.y - P.y) / (Q.x - P.x);
      }
      const x3 = lambda ** 2 - P.x - Q.x;
      const y3 = lambda * (P.x - x3) - P.y;
      return { x: x3, y: y3 };
    }

    function drawLine(P, Q, color = "#888") {
      const A = toCanvas(P);
      const B = toCanvas(Q);
      ctx.beginPath();
      ctx.moveTo(A.x, A.y);
      ctx.lineTo(B.x, B.y);
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    let P = { x: -1, y: Math.sqrt((-1) ** 3 + a * (-1) + b) };
    let Q = { x: 1, y: Math.sqrt((1) ** 3 + a * (1) + b) };

    function render() {
      origin = { x: width / 2, y: height / 2 };
      ctx.clearRect(0, 0, width, height);
      drawGrid();
      drawCurve();
      drawPoint(P, "blue", "P");
      drawPoint(Q, "green", "Q");

      const R = addPoints(P, Q);
      if (R) {
        drawLine(P, Q);
        drawLine(R, inversePoint(R));
        drawPoint(R, "red", "R'");
        drawPoint(inversePoint(R), "purple", "R");
      }
    }

    render();

    let dragging = null;
    canvas.addEventListener("mousedown", e => {
      const m = fromCanvas({ x: e.offsetX, y: e.offsetY });
      if (Math.hypot(m.x - P.x, m.y - P.y) < 0.5) dragging = "P";
      else if (Math.hypot(m.x - Q.x, m.y - Q.y) < 0.5) dragging = "Q";
    });

    canvas.addEventListener("mousemove", e => {
      if (!dragging) return;
      const m = fromCanvas({ x: e.offsetX, y: e.offsetY });
      const rhs = m.x ** 3 + a * m.x + b;
      if (rhs >= 0) {
        const y = Math.sqrt(rhs);
        if (dragging === "P") P = { x: m.x, y };
        else if (dragging === "Q") Q = { x: m.x, y };
        render();
      }
    });

    canvas.addEventListener("mouseup", () => dragging = null);

    window.addEventListener("keydown", e => {
      if (e.key === "+" || e.key === "=") {
        scale *= 1.2;
        render();
      } else if (e.key === "-") {
        scale /= 1.2;
        render();
      }
    });
  </script>
</body>
</html>
